= Evaluation

Project configuration for Hercules CI is written in the Nix language. Your agent will evaluate the `herculesCI` attribute of a flake, or, if a repository does not contain `flake.nix`, the agent will look for that attribute in `nix/ci.nix`, `ci.nix` or `default.nix`.

If the `herculesCI` attribute is not present, evaluation will fall back to the xref:legacy-evaluation.adoc[pre-0.9 evaluation behavior].

A simple example of an `herculesCI` attribute looks as follows:

[source,nix]
----
  herculesCI = { ... }: {
    onPush.default = {
      outputs = { ... }: {
        # Attributes here will be built for each push.
        hello = pkgs.hello;
      };
    };
  };
----

== `herculesCI` Value

The `herculesCI` attribute can be a function producing an attribute set. If no parameters are needed, xref:attributes-herculesCI[the attribute set] can be provided directly instead.

[[params-herculesCI]]
== `herculesCI` Parameters

// hercules-ci-agent/src/Hercules/Agent/NixFile/HerculesCIArgs.hs
[[params-herculesCI-commit]]
=== `ref`, `branch`, `tag`, `rev`, `shortRev`

These strings represent the version and origin of the source that led to the `herculesCI` attribute.

`branch` and `tag` may be null.

// hercules-ci-agent/src/Hercules/Agent/NixFile/HerculesCIArgs.hs
[[param-herculesCI-primaryRepo]]
=== `primaryRepo`

Information about the repository and revision of the sources that led to the `herculesCI` attribute.

[[param-herculesCI-primaryRepo.outPath]]
=== `primaryRepo.outPath`

A path containing the files of the checked out revision.

[[param-herculesCI-primaryRepo-commit]]
=== `primaryRepo.ref`, `primaryRepo.branch`, `primaryRepo.tag`, `primaryRepo.rev`, `primaryRepo.shortRev`

Same as top-level <<params-herculesCI-commit>>.

// hercules-ci-agent/src/Hercules/Agent/NixFile/HerculesCIArgs.hs
[[param-herculesCI]]
=== `herculesCI`

Information about the Hercules CI instance the agent is connected to. This is mostly for Hercules CI Enterprise users; who self-manage the entire stack.

// hercules-ci-agent/src/Hercules/Agent/NixFile/HerculesCIArgs.hs
[[param-herculesCI-herculesCI.apiBaseUrl]]
=== `herculesCI.apiBaseUrl`

The base URL of the Hercules CI API. This can be used to differentiate behavior on Hercules CI Enterprise. On non-enterprise agents, the value is `https://hercules-ci.com[https://hercules-ci.com]`. This matches xref:agent-config.adoc#apiBaseUrl[the configuration file].

[[attributes-herculesCI]]
== `herculesCI` Attributes

The `herculesCI` value primarily defines handlers for what to build and run for various events, such as `onPush`.

// hercules-ci-agent/src/Hercules/Agent/NixFile.hs OnPushSchema
[[attributes-herculesCI.onPush]]
=== `onPush.<name>`

This declares what to do when a Git `ref` is updated, such as when you push a commit or after you merge a pull request.

Multiple jobs will be created when multiple attributes are declared, with different values for the  `<name>` placeholder. The name will be used as part of the commit status for each resulting job.

// The ability to declare multiple jobs per event is mainly intended to support multiple choices of `extraInputs`.

// hercules-ci-agent/src/Hercules/Agent/NixFile.hs InputDeclSchema
[[attribute-herculesCI.onPush-extraInputs]]
=== `onPush.<name>.extraInputs.<inputName>`

Specifies a location to an unpinned dependency. The name chosen for the `<inputName>` placeholder will be used as an attribute argument for <<params-herculesCI.onPush-outputs>>.

[[attribute-herculesCI.onPush-extraInputs-project]]
=== `onPush.<name>.extraInputs.<inputName>.project`

The name of a repository in the same organization.

[[attribute-herculesCI.onPush-extraInputs-ref]]
=== `onPush.<name>.extraInputs.<inputName>.ref`

A Git ref indicating the branch or tag to check out. Example: `refs/heads/staging` for a branch called `staging`.

[[attribute-herculesCI.onPush-outputs]]
=== `onPush.<name>.outputs`

[[params-herculesCI.onPush-outputs]]
=== `onPush.<name>.outputs` Parameters

The arguments to the `outputs` are sourced from <<attribute-herculesCI.onPush-extraInputs>>, by resolving the inputs to pinned revisions before creating the job.

You can find the pinned revisions in the dashboard or by clicking a commit status.

Other information besides `extraInputs` can be retrieved from the xref:params-herculesCI[`herculesCI` parameters].

[[attributes-herculesCI.onPush-outputs]]
=== `onPush.<name>.outputs` Attributes

These "output" attributes can be

 * derivations,
 * effects,
 * attribute sets containing further "outputs", in a nested manner,
 * other types, which will be ignored.

During the execution of the job, first, all derivations will be built. If the build went well, all effects will run, concurrently with effects in the same job, but only after preceding jobs have either completed or failed to build.

==== Derivations, shells and effects

All three are defined through derivations.

 * A derivation marked by the attribute `isEffect = true` is categorized as an Effect and will be run in the Effects sandbox. Effects must be defined below the `outputs.effects` attribute.

 * A derivation marked by the `buildDependenciesOnly = true` attribute will not be built, but its dependencies will.

 * A derivation with `phases = ["noBuildPhase"]` is treated as if it had `buildDependenciesOnly = true`. This includes Nixpkgs' `mkShell`.

 * A derivation with `ignoreFailure = true` will be built, but not included in the job status and commit status. This is only useful when a build is unpredictable and irrelevant to the development process. `requireFailure` may be a better option, to avoid regressions after repairs.

 * A derivation with `requireFailure = true` will be built and included in the job status and commit status, but with its build status reversed. This is useful during development to track for example which tests are known to fail. If during development a problem is solved, you are required to remove the attribute, which is necessary to avoid regressions.

==== Attribute sets

Unlike the legacy format and `nix-build`, nested attribute sets _are_ traversed by default.

You can mark attribute sets not to be traversed by adding an attribute `recurseForDerivations = false` inside them, as is done by the function `lib.dontRecurseIntoAttrs` of type `attrs -> attrs`.
